# Progpedia

## Что это за программа
Приложение OMIS помогает инженерам мониторинга контролировать заявки подрядчика: хранит их в базе данных, отслеживает статусы по письмам из Outlook и напоминает в Telegram, если подрядчик задерживается. Веб-интерфейс на Flask позволяет быстро добавлять заявки и видеть актуальную информацию, а планировщик автоматически запускает проверку почты и уведомления.

## Как работает app.py
Модуль разворачивает веб-интерфейс на Flask:
- маршруты `GET /`, `/requests`, `/new`, `POST /add_request` обслуживают таблицу заявок, форму создания и обработчик отправки;
- шаблоны из каталога `templates/` отвечают за интерфейс; Flash-сообщения помогают показать результат создания заявки;
- взаимодействие с базой происходит через функции модуля `database`;
- фильтр `format_ts` форматирует временные метки в компактный вид (дата и время в двух строках);
- значение секретного ключа для Flask оставлено временным и должно быть вынесено в переменные окружения перед продуктивным запуском.

## Как работает database.py
Модуль работает с SQLite и создаёт файл базы (путь приходит из `config.py` или переменной окружения). Основные элементы:
- `init_db()` — создаёт таблицу заявок, добавляет недостающие столбцы и индекс по времени обновления;
- `add_request()` — сохраняет новую заявку с автором, статусом «заявка отправлена» и отметками `created_at`/`status_updated_at`;
- `update_status()` — меняет статус существующей заявки и фиксирует время изменения;
- `update_comment()` — перезаписывает комментарий и автора (по умолчанию используется «Робот»);
- `get_delayed_requests()` — ищет заявки, которые не обновлялись дольше указанного порога;
- `get_requests()` — возвращает список заявок, отсортированный по времени последнего обновления.

Все операции выполняются через контекстный менеджер `_connect()`, который открывает соединение с SQLite, включает `Row`-фабрику и бережно обрабатывает транзакции. Логирование построено на `logging`, поэтому любые ошибки фиксируются в журнале.

## Как работает mail_checker.py
Модуль обрабатывает письма подрядчика. Ключевые части:
- `STATUS_KEYWORDS` — словарь ключевых фраз для сопоставления текста письма со статусом заявки;
- `ContractorMessage` (dataclass) описывает извлечённые из письма данные (номер заявки, позиция, статус, комментарий, время, автор);
- `_detect_status()` и `_extract_numbers()` разбирают текст письма без внешних зависимостей;
- `_compose_comment()` формирует короткую заметку для истории заявок;
- `FAKE_CONTRACTOR_MESSAGES` — тестовый набор писем для локальной отладки без Outlook;
- `fetch_contractor_messages()` пока работает в тестовом режиме (`use_fake=True`). Позже сюда добавится интеграция с Outlook (например, через `exchangelib`);
- `process_mailbox()` проходит по письмам, обновляет статусы (`update_status`), сохраняет комментарии (`update_comment`) и возвращает небольшой отчёт.

## Как работает notifier.py
Модуль `project_package/project/notifier.py` отвечает за Telegram-уведомления о задержках:
- `_format_delay_message()` собирает текст напоминания: номер заявки, позиция, текущий статус и время последнего обновления;
- `send_message()` отправляет сообщение через Telegram Bot API. Если токен или chat_id не заданы, модуль записывает сообщение в лог `[FAKE TELEGRAM]`, что удобно для тестов без бота;
- `notify_delays(minutes=60, send=True)` запрашивает задержавшиеся заявки (`database.get_delayed_requests`) и для каждой формирует и отправляет уведомление. При `send=False` сообщения только логируются, что полезно для сухого прогона.

Токен и идентификатор чата поступают из переменных окружения `OMIS_TELEGRAM_TOKEN` и `OMIS_TELEGRAM_CHAT_ID`, которые считываются в `config.py`. В боевом режиме обязательно задать эти значения, иначе уведомления не уйдут.

## Для чего нужна переменная __all__
`__all__` определяет, какие имена экспортирует модуль при `from ... import *`. Сейчас список содержит публичные функции и константы (`DEFAULT_STATUS`, `ROBOT_AUTHOR`, `add_request`, `get_delayed_requests`, `get_requests`, `init_db`, `update_comment`, `update_status`). Если нужно открыть наружу новое имя, добавьте его в список; чтобы скрыть служебное — уберите и убедитесь, что внешний код не зависит от него.

## Как подключить другого Telegram-бота
1. Получите токен: в Telegram напишите `@BotFather`, выберите `/token` для существующего бота или `/newbot` для нового, скопируйте выданный токен формата `123456789:AA...`.
2. Добавьте бота в рабочий чат и отправьте туда любое сообщение (иначе Telegram не вернёт chat_id).
3. Узнайте chat_id: откройте в браузере или через `curl` URL `https://api.telegram.org/bot<ТОКЕН>/getUpdates` и найдите поле `message.chat.id` в ответе. Для супергрупп идентификатор начинается с `-100`.
4. Экспортируйте переменные окружения перед запуском OMIS:
   - Windows PowerShell:
     ```powershell
     $env:OMIS_TELEGRAM_TOKEN = '123456789:AA...'
     $env:OMIS_TELEGRAM_CHAT_ID = '-1001234567890'
     ```
   - Linux/macOS (bash/zsh):
     ```bash
     export OMIS_TELEGRAM_TOKEN='123456789:AA...'
     export OMIS_TELEGRAM_CHAT_ID='-1001234567890'
     ```
5. Проверьте подключение:
   ```python
   from project_package.project.notifier import send_message
   send_message("Тестовое уведомление из OMIS")
   ```
   Если переменные заданы верно, функция вернёт `True`, и сообщение придёт в чат. При отсутствии настроек в лог попадёт `[FAKE TELEGRAM]`.
6. Запустите планировщик или приложение, которое вызывает `notify_delays()`, и убедитесь, что уведомления приходят автоматически при задержках.

Храните реальные токены только в защищённой среде (например, в `.env`, который не попадает в Git), а для документации используйте вымышленные значения.
