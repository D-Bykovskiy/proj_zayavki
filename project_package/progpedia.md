# Progpedia

## Что это за программа
Приложение OMIS помогает инженерам мониторинга контролировать заявки подрядчика: хранит их в базе данных, отслеживает изменения статусов по письмам из Outlook и вовремя напоминает в Telegram, если подрядчик задерживается. Веб-интерфейс на Flask позволяет быстро добавлять новые заявки и просматривать актуальное состояние, а планировщик автоматически запускает проверку почты и уведомления.

## Как работает pp.py
Файл поднимает веб-интерфейс на Flask:
- маршруты GET /, /requests, /new, POST /add_request — просмотр списка заявок, форма и обработка создания;
- в шаблонах используются таблица и форма из каталога 	emplates, сообщениях о результате помогают lash-уведомления;
- данные читаются и сохраняются через модуль database, а фильтр ormat_ts форматирует даты в таблице на две строки (YYYY.MM.DD и HH:MM);
- базовый секретный ключ помечен как временный и должен быть вынесен в переменные окружения или конфиг перед продакшном.

## Как работает database.py
Модуль отвечает за работу с SQLite. Он создаёт файл базы данных (путь берётся из config.py или переменной окружения) и включает ключевые функции:
- init_db() — создаёт таблицу заявок, добавляет недостающие столбцы и индекс по времени обновления;
- dd_request() — добавляет новую заявку с автором комментария, статусом «заявка отправлена» и отметками времени created_at/status_updated_at;
- update_status() — обновляет статус существующей заявки и фиксирует время изменения;
- update_comment() — сохраняет комментарий и автора (по умолчанию «Робот»);
- get_delayed_requests() — возвращает заявки, которые не обновлялись дольше заданного порога;
- get_requests() — отдаёт список заявок, отсортированный по времени последнего обновления.

Внутри используется менеджер контекста _connect(), который открывает соединение с SQLite, включает фабрику строк Row, выполняет коммит операций и откатывает транзакцию при ошибке. Все действия логируются через logging, поэтому их легко отслеживать.

## Как работает mail_checker.py
Обработка почты вынесена в отдельный модуль. Основные элементы:
- STATUS_KEYWORDS — таблица ключевых слов для сопоставления текста письма со статусом заявки;
- ContractorMessage (dataclass) — описывает извлечённые из письма данные (номер заявки, позиция, статус, комментарий, время, отправитель);
- _detect_status() и _extract_numbers() — внутренние функции для анализа текста письма без внешних зависимостей;
- _compose_comment() — формирует короткий комментарий на основе темы и первых строк письма;
- FAKE_CONTRACTOR_MESSAGES — тестовый набор сообщений. Здесь можно менять темы/тексты, чтобы проверять логику без доступа к Outlook (помечено в коде);
- etch_contractor_messages() — пока работает в тестовом режиме (параметр use_fake). Когда появится доступ к Outlook, функцию можно дополнить реальным подключением (например, через exchangelib).
- process_mailbox() — основной метод: перебирает письма, обновляет статус заявки (update_status), сохраняет комментарий (update_comment) и возвращает короткие отчёты о результатах.

## Как работает 
otifier.py
Модуль занимается уведомлениями в Telegram:
- _format_delay_message() — собирает текст напоминания на основе данных заявки (номер, позиция, статус, время последнего изменения);
- send_message() — отправляет сообщение через Bot API или пишет в лог, если токен/чат не заданы (тестовый режим помечен комментариями и включается по умолчанию);
- 
otify_delays() — получает список задержавшихся заявок (database.get_delayed_requests(minutes)) и для каждой формирует сообщение, отправляя его через send_message() или выводя в лог при send=False.
Параметры бота подаются через переменные окружения OMIS_TELEGRAM_TOKEN и OMIS_TELEGRAM_CHAT_ID, которые читаются в config.py.

## Для чего нужна переменная __all__
Переменная __all__ определяет, какие имена экспортирует модуль при импорте вида rom project.database import *. Сейчас туда входят DEFAULT_STATUS, ROBOT_AUTHOR, dd_request, get_delayed_requests, get_requests, init_db, update_comment, update_status, то есть только публичные функции и константы. Если нужно предоставить наружу новую функцию, добавь её название в список. Если хочешь скрыть служебную часть, убери её из __all__ и убедись, что внешний код не полагался на импорт этого имени.