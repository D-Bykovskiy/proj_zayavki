# Progpedia

## Что это за программа
Приложение OMIS помогает инженерам мониторинга контролировать заявки подрядчика: хранит их в базе данных, отслеживает статусы по письмам из Outlook и напоминает в Telegram, если подрядчик задерживается. Веб-интерфейс на Flask позволяет быстро добавлять заявки и видеть актуальную информацию, а регулярные задания обновляют статусы и уведомления.

## Как работает app.py
Модуль разворачивает веб-интерфейс на Flask:
- маршруты `GET /`, `/requests`, `/new`, `POST /add_request` обслуживают таблицу заявок, форму создания и обработчик отправки;
- шаблоны из каталога `templates/` отвечают за интерфейс; Flash-сообщения помогают показать результат создания заявки;
- взаимодействие с базой происходит через функции модуля `database`;
- фильтр `format_ts` форматирует временные метки в компактный вид (дата и время в двух строках);
- значение секретного ключа для Flask оставлено временным и должно быть вынесено в переменные окружения перед продуктивным запуском.

## Как работает database.py
Модуль работает с SQLite и создаёт файл базы (путь приходит из `config.py` или переменной окружения). Основные элементы:
- `init_db()` — создаёт таблицу заявок, добавляет недостающие столбцы и индекс по времени обновления;
- `add_request()` — сохраняет новую заявку с автором, статусом «заявка отправлена» и отметками `created_at`/`status_updated_at`;
- `update_status()` — меняет статус существующей заявки и фиксирует время изменения;
- `update_comment()` — перезаписывает комментарий и автора (по умолчанию используется «Робот»);
- `get_delayed_requests()` — ищет заявки, которые не обновлялись дольше указанного порога;
- `get_requests()` — возвращает список заявок, отсортированный по времени последнего обновления.

Все операции выполняются через контекстный менеджер `_connect()`, который открывает соединение с SQLite, включает `Row`-фабрику и бережно обрабатывает транзакции. Логирование построено на `logging`, поэтому любые ошибки фиксируются в журнале.

## Как работает mail_checker.py
Модуль обрабатывает письма подрядчика. Ключевые части:
- `STATUS_KEYWORDS` — словарь ключевых фраз для сопоставления текста письма со статусом заявки;
- `ContractorMessage` (dataclass) описывает извлечённые из письма данные (номер заявки, позиция, статус, комментарий, время, автор);
- `_detect_status()` и `_extract_numbers()` разбирают текст письма без внешних зависимостей;
- `_compose_comment()` формирует короткую заметку для истории заявок;
- `FAKE_CONTRACTOR_MESSAGES` — тестовый набор писем для локальной отладки без Outlook;
- `fetch_contractor_messages()` пока работает в тестовом режиме (`use_fake=True`). Позже сюда добавится интеграция с Outlook (например, через `exchangelib`);
- `process_mailbox()` проходит по письмам, обновляет статусы (`update_status`), сохраняет комментарии (`update_comment`) и возвращает небольшой отчёт;
- CLI-запуск: `python -m project_package.project.mail_checker [--fake]`.

## Как работает notifier.py
Модуль `project_package/project/notifier.py` отвечает за Telegram-уведомления о задержках:
- `_format_delay_message()` собирает текст напоминания: номер заявки, позиция, текущий статус и время последнего обновления;
- `send_message()` отправляет сообщение через Telegram Bot API. Если токен или chat_id не заданы, модуль записывает сообщение в лог `[FAKE TELEGRAM]`, что удобно для тестов без бота;
- `notify_delays(minutes=60, send=True)` запрашивает задержавшиеся заявки (`database.get_delayed_requests`) и для каждой формирует и отправляет уведомление. При `send=False` сообщения только логируются, что полезно для сухого прогона;
- CLI-запуск: `python -m project_package.project.notifier [--minutes 60] [--dry-run]`.

Токен и идентификатор чата поступают из переменных окружения `OMIS_TELEGRAM_TOKEN` и `OMIS_TELEGRAM_CHAT_ID`, которые считываются в `config.py`. В боевом режиме обязательно задать эти значения, иначе уведомления не уйдут.

## Для чего нужна переменная __all__
`__all__` определяет, какие имена экспортирует модуль при `from ... import *`. Сейчас список содержит публичные функции и константы (`DEFAULT_STATUS`, `ROBOT_AUTHOR`, `add_request`, `get_delayed_requests`, `get_requests`, `init_db`, `update_comment`, `update_status`). Если нужно открыть наружу новое имя, добавьте его в список; чтобы скрыть служебное — уберите и убедитесь, что внешний код не зависит от него.

## Как подключить другого Telegram-бота
1. Получите токен: в Telegram напишите `@BotFather`, выберите `/token` для существующего бота или `/newbot` для нового, скопируйте выданный токен формата `123456789:AA...`.
2. Добавьте бота в рабочий чат и отправьте туда любое сообщение (иначе Telegram не вернёт chat_id).
3. Узнайте chat_id: откройте в браузере или через `curl` URL `https://api.telegram.org/bot<ТОКЕН>/getUpdates` и найдите поле `message.chat.id` в ответе. Для супергрупп идентификатор начинается с `-100`.
4. Экспортируйте переменные окружения перед запуском OMIS:
   - Windows PowerShell:
     ```powershell
     $env:OMIS_TELEGRAM_TOKEN = '123456789:AA...'
     $env:OMIS_TELEGRAM_CHAT_ID = '-1001234567890'
     ```
   - Linux/macOS (bash/zsh):
     ```bash
     export OMIS_TELEGRAM_TOKEN='123456789:AA...'
     export OMIS_TELEGRAM_CHAT_ID='-1001234567890'
     ```
5. Проверьте подключение:
   ```python
   from project_package.project.notifier import send_message
   send_message("Тестовое уведомление из OMIS")
   ```
   Если переменные заданы верно, функция вернёт `True`, и сообщение придёт в чат. При отсутствии настроек в лог попадёт `[FAKE TELEGRAM]`.
6. Настройте периодический запуск CLI-команд (cron/Task Scheduler), чтобы уведомления отправлялись автоматически.

Храните реальные токены только в защищённой среде (например, в `.env`, который не попадает в Git), а для документации используйте вымышленные значения.

## Развёртывание на сервере
1. Подготовьте окружение: установите Python 3.11+, git и зависимости `pip install flask requests python-dotenv` (если появится интеграция с Outlook — добавьте `exchangelib`).
2. Склонируйте репозиторий и создайте виртуальное окружение:
   ```bash
   git clone <repo-url>
   cd omis
   python -m venv .venv
   source .venv/bin/activate  # Windows: .venv\Scripts\activate
   pip install -r requirements.txt || pip install flask requests python-dotenv
   ```
3. Настройте переменные окружения (например, через `.env`): `OMIS_DB_FILE` (опционально), `OMIS_TELEGRAM_TOKEN`, `OMIS_TELEGRAM_CHAT_ID`.
4. Инициализируйте базу и запустите веб-приложение. Для разработки подойдёт `python -m project_package.project.app`, для сервера используйте WSGI-сервер, например gunicorn:
   ```bash
   gunicorn --bind 0.0.0.0:8000 project_package.project.app:app
   ```
5. Настройте обратный прокси (nginx/Apache/IIS) и откройте порт, чтобы пользователи могли открыть `http(s)://<server-host>/`.
6. Создайте два задания cron/Task Scheduler: `python -m project_package.project.mail_checker` и `python -m project_package.project.notifier --minutes 60` каждые 10 минут; логи перенаправьте в файлы.
7. Убедитесь, что после перезагрузки сервера сервисы стартуют автоматически (systemd service/Task Scheduler).

### Как подключаются пользователи
- Сотрудники открывают веб-интерфейс в браузере и работают с заявками через формы и таблицы.
- Telegram-бот отправляет уведомления в общий чат; достаточно добавить туда нужных людей.
- Администратор следит за журналами (`/var/log/omis-*.log` или Task Scheduler History) и перезапускает сервисы при сбоях.\n\n## Как работает runner.py
- project_package/runner.py объединяет запуск mail_checker и 
otifier одной командой python -m project_package.runner.
- Опции --fake-mail, --dry-run, --minutes, --skip-mail, --skip-notifier помогают моделировать разные ситуации.
- Эту команду можно использовать в cron/systemd/Task Scheduler, а также для ручной проверки цепочки.

## Сценарии (scenario_runner.py)
- python -m project_package.scenario_runner --scenario NAME выполняет заранее подготовленную последовательность шагов.
- Сценарии описываются в ops/testing/scenarios.json (JSON-формат).
- Доступна команда --list для просмотра доступных сценариев и --file для указания альтернативного набора.

## Подключение почты Outlook

1. Установите зависимость `exchangelib` в активном виртуальном окружении:

   ```bash
   pip install exchangelib
   ```

2. Настройте переменные окружения, которые использует модуль `mail_checker`:
   - `OMIS_OUTLOOK_EMAIL` — рабочий адрес почтового ящика.
   - `OMIS_OUTLOOK_CLIENT_ID` — идентификатор зарегистрированного Azure-приложения.
   - `OMIS_OUTLOOK_CLIENT_SECRET` — секрет клиента из Azure.
   - `OMIS_OUTLOOK_TENANT_ID` — идентификатор вашего тенанта Microsoft 365.
   - `OMIS_OUTLOOK_FOLDER` *(опционально)* — путь к вложенной папке (через `/`, например `Inbox/Contracts`).
   - `OMIS_OUTLOOK_LOOKBACK_MINUTES` *(опционально)* — окно синхронизации в минутах, по умолчанию 1440.
   - `OMIS_OUTLOOK_MAX_MESSAGES` *(опционально)* — ограничение на количество писем за проход (по умолчанию 50).

3. Для тестового запуска почтового парсера выполните:

   ```bash
   python -m project_package.project.mail_checker --log-level DEBUG
   ```

   Уберите флаг `--fake`, чтобы использовать реальный Outlook. В режиме отладки журнал покажет выбранную папку и результаты обработки.

4. Если параметры не заданы или `exchangelib` не установлен, скрипт автоматически использует подготовленные тестовые письма, чтобы не блокировать локальную разработку.

## Быстрый запуск сервера (виртуального и боевого)

Модуль `project_package/project/server_setup.py` генерирует пошаговый план подготовки сервера. Скрипт не выполняет команды сам, а печатает их списком, чтобы оператор мог прогнать их вручную или встроить в Ansible/SSH-скрипт.

1. Сгенерируйте план для тестовой ВМ:

   ```bash
   python -m project_package.project.server_setup virtual --no-nginx --extra-pip gunicorn
   ```

   В вывод попадут команды для установки Python, клонирования репозитория и запуска `mail_checker` в режиме `--fake`. Конфигурация Nginx отключена флагом `--no-nginx`, что удобно для локальных песочниц.

2. Для боевого сервера (c Nginx и системным сервисом) выполните:

   ```bash
   python -m project_package.project.server_setup production --service-name omis-prod --extra-package postgresql-client
   ```

   Скрипт предложит:
   - обновить пакеты и поставить `nginx`, `pipx`, Python нужной версии;
   - создать системного пользователя `omis` и каталог `/opt/omis`;
   - настроить виртуальное окружение и установить зависимости (`flask`, `requests`, `python-dotenv`, `exchangelib` + дополнительные пакеты);
   - сгенерировать Unit-файл systemd и конфиг Nginx (прокси на 5000 порт);
   - выполнить базовые проверки (`systemctl status`, `journalctl`, `curl`).

3. Все пути настраиваются ключами CLI:
   - `--project-dir` — куда клонировать репозиторий (по умолчанию `/opt/omis`).
   - `--service-user` — системный пользователь для сервиса.
   - `--python-version` — версия Python, которую следует поставить (формат `3.11`, `3.12`...).
   - `--extra-package` / `--extra-pip` — дополнительный список пакетов APT и pip.

4. План удобно переносить в Ansible:

   ```yaml
   - name: Prepare OMIS
     hosts: omis
     tasks:
       - name: Run generated shell snippet
         ansible.builtin.shell: >
           sudo apt-get update && sudo apt-get install -y python3.11 python3.11-venv git pipx nginx
           # команды продолжаются...
   ```

5. Логика генерации плана:
   - В тестовом (`virtual`) профиле завершающий шаг запускает `mail_checker` c `--fake`, чтобы проверить окружение без подключений к Outlook.
   - В боевом (`production`/`real`/`baremetal`) профиле выполняется «настоящий» прогон `mail_checker` в обычном режиме, после чего сервис фиксируется через systemd.

Все ключевые комментарии и шаблоны unit-файлов находятся в `server_setup.py`, так что сценарий легко расширяется под kube/helm или дополнительные службы.
