# Progpedia

## Что это за программа
Приложение OMIS помогает инженерам мониторинга контролировать заявки подрядчика: хранит их в базе данных, отслеживает статусы по письмам из Outlook и напоминает в Telegram, если подрядчик задерживается. Веб-интерфейс на Flask позволяет быстро добавлять заявки и видеть актуальную информацию, а регулярные задания обновляют статусы и уведомления.

## Как работает app.py
Модуль разворачивает веб-интерфейс на Flask:
- маршруты `GET /`, `/requests`, `/new`, `POST /add_request` обслуживают таблицу заявок, форму создания и обработчик отправки;
- шаблоны из каталога `templates/` отвечают за интерфейс; Flash-сообщения помогают показать результат создания заявки;
- взаимодействие с базой происходит через функции модуля `database`;
- фильтр `format_ts` форматирует временные метки в компактный вид (дата и время в двух строках);
- значение секретного ключа для Flask оставлено временным и должно быть вынесено в переменные окружения перед продуктивным запуском.

## Как работает database.py
Модуль работает с SQLite и создаёт файл базы (путь приходит из `config.py` или переменной окружения). Основные элементы:
- `init_db()` — создаёт таблицу заявок, добавляет недостающие столбцы и индекс по времени обновления;
- `add_request()` — сохраняет новую заявку с автором, статусом «заявка отправлена» и отметками `created_at`/`status_updated_at`;
- `update_status()` — меняет статус существующей заявки и фиксирует время изменения;
- `update_comment()` — перезаписывает комментарий и автора (по умолчанию используется «Робот»);
- `get_delayed_requests()` — ищет заявки, которые не обновлялись дольше указанного порога;
- `get_requests()` — возвращает список заявок, отсортированный по времени последнего обновления.

Все операции выполняются через контекстный менеджер `_connect()`, который открывает соединение с SQLite, включает `Row`-фабрику и бережно обрабатывает транзакции. Логирование построено на `logging`, поэтому любые ошибки фиксируются в журнале.

## Как работает mail_checker.py
Модуль обрабатывает письма подрядчика. Ключевые части:
- `STATUS_KEYWORDS` — словарь ключевых фраз для сопоставления текста письма со статусом заявки;
- `ContractorMessage` (dataclass) описывает извлечённые из письма данные (номер заявки, позиция, статус, комментарий, время, автор);
- `_detect_status()` и `_extract_numbers()` разбирают текст письма без внешних зависимостей;
- `_compose_comment()` формирует короткую заметку для истории заявок;
- `FAKE_CONTRACTOR_MESSAGES` — тестовый набор писем для локальной отладки без Outlook;
- `fetch_contractor_messages()` пока работает в тестовом режиме (`use_fake=True`). Позже сюда добавится интеграция с Outlook (например, через `exchangelib`);
- `process_mailbox()` проходит по письмам, обновляет статусы (`update_status`), сохраняет комментарии (`update_comment`) и возвращает небольшой отчёт;
- CLI-запуск: `python -m project_package.project.mail_checker [--fake]`.

## Как работает notifier.py
Модуль `project_package/project/notifier.py` отвечает за Telegram-уведомления о задержках:
- `_format_delay_message()` собирает текст напоминания: номер заявки, позиция, текущий статус и время последнего обновления;
- `send_message()` отправляет сообщение через Telegram Bot API. Если токен или chat_id не заданы, модуль записывает сообщение в лог `[FAKE TELEGRAM]`, что удобно для тестов без бота;
- `notify_delays(minutes=60, send=True)` запрашивает задержавшиеся заявки (`database.get_delayed_requests`) и для каждой формирует и отправляет уведомление. При `send=False` сообщения только логируются, что полезно для сухого прогона;
- CLI-запуск: `python -m project_package.project.notifier [--minutes 60] [--dry-run]`.

Токен и идентификатор чата поступают из переменных окружения `OMIS_TELEGRAM_TOKEN` и `OMIS_TELEGRAM_CHAT_ID`, которые считываются в `config.py`. В боевом режиме обязательно задать эти значения, иначе уведомления не уйдут.

## Для чего нужна переменная __all__
`__all__` определяет, какие имена экспортирует модуль при `from ... import *`. Сейчас список содержит публичные функции и константы (`DEFAULT_STATUS`, `ROBOT_AUTHOR`, `add_request`, `get_delayed_requests`, `get_requests`, `init_db`, `update_comment`, `update_status`). Если нужно открыть наружу новое имя, добавьте его в список; чтобы скрыть служебное — уберите и убедитесь, что внешний код не зависит от него.

## Как подключить другого Telegram-бота
1. Получите токен: в Telegram напишите `@BotFather`, выберите `/token` для существующего бота или `/newbot` для нового, скопируйте выданный токен формата `123456789:AA...`.
2. Добавьте бота в рабочий чат и отправьте туда любое сообщение (иначе Telegram не вернёт chat_id).
3. Узнайте chat_id: откройте в браузере или через `curl` URL `https://api.telegram.org/bot<ТОКЕН>/getUpdates` и найдите поле `message.chat.id` в ответе. Для супергрупп идентификатор начинается с `-100`.
4. Экспортируйте переменные окружения перед запуском OMIS:
   - Windows PowerShell:
     ```powershell
     $env:OMIS_TELEGRAM_TOKEN = '123456789:AA...'
     $env:OMIS_TELEGRAM_CHAT_ID = '-1001234567890'
     ```
   - Linux/macOS (bash/zsh):
     ```bash
     export OMIS_TELEGRAM_TOKEN='123456789:AA...'
     export OMIS_TELEGRAM_CHAT_ID='-1001234567890'
     ```
5. Проверьте подключение:
   ```python
   from project_package.project.notifier import send_message
   send_message("Тестовое уведомление из OMIS")
   ```
   Если переменные заданы верно, функция вернёт `True`, и сообщение придёт в чат. При отсутствии настроек в лог попадёт `[FAKE TELEGRAM]`.
6. Настройте периодический запуск CLI-команд (cron/Task Scheduler), чтобы уведомления отправлялись автоматически.

Храните реальные токены только в защищённой среде (например, в `.env`, который не попадает в Git), а для документации используйте вымышленные значения.

## Развёртывание на сервере
1. Подготовьте окружение: установите Python 3.11+, git и зависимости `pip install flask requests python-dotenv` (если появится интеграция с Outlook — добавьте `exchangelib`).
2. Склонируйте репозиторий и создайте виртуальное окружение:
   ```bash
   git clone <repo-url>
   cd omis
   python -m venv .venv
   source .venv/bin/activate  # Windows: .venv\Scripts\activate
   pip install -r requirements.txt || pip install flask requests python-dotenv
   ```
3. Настройте переменные окружения (например, через `.env`): `OMIS_DB_FILE` (опционально), `OMIS_TELEGRAM_TOKEN`, `OMIS_TELEGRAM_CHAT_ID`.
4. Инициализируйте базу и запустите веб-приложение. Для разработки подойдёт `python -m project_package.project.app`, для сервера используйте WSGI-сервер, например gunicorn:
   ```bash
   gunicorn --bind 0.0.0.0:8000 project_package.project.app:app
   ```
5. Настройте обратный прокси (nginx/Apache/IIS) и откройте порт, чтобы пользователи могли открыть `http(s)://<server-host>/`.
6. Создайте два задания cron/Task Scheduler: `python -m project_package.project.mail_checker` и `python -m project_package.project.notifier --minutes 60` каждые 10 минут; логи перенаправьте в файлы.
7. Убедитесь, что после перезагрузки сервера сервисы стартуют автоматически (systemd service/Task Scheduler).

### Как подключаются пользователи
- Сотрудники открывают веб-интерфейс в браузере и работают с заявками через формы и таблицы.
- Telegram-бот отправляет уведомления в общий чат; достаточно добавить туда нужных людей.
- Администратор следит за журналами (`/var/log/omis-*.log` или Task Scheduler History) и перезапускает сервисы при сбоях.\n\n## Как работает runner.py
- project_package/runner.py объединяет запуск mail_checker и 
otifier одной командой python -m project_package.runner.
- Опции --fake-mail, --dry-run, --minutes, --skip-mail, --skip-notifier помогают моделировать разные ситуации.
- Эту команду можно использовать в cron/systemd/Task Scheduler, а также для ручной проверки цепочки.

## Сценарии (scenario_runner.py)
- python -m project_package.scenario_runner --scenario NAME выполняет заранее подготовленную последовательность шагов.
- Сценарии описываются в ops/testing/scenarios.json (JSON-формат).
- Доступна команда --list для просмотра доступных сценариев и --file для указания альтернативного набора.
